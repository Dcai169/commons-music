import { useState, useRef, useEffect, useCallback } from 'react';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var noop = function noop() {};

function useSpotifyWebPlaybackSdk(_ref) {
  var name = _ref.name,
      _getOAuthToken = _ref.getOAuthToken,
      _ref$accountError = _ref.accountError,
      accountError = _ref$accountError === void 0 ? noop : _ref$accountError,
      _ref$onReady = _ref.onReady,
      onReady = _ref$onReady === void 0 ? noop : _ref$onReady,
      _ref$onPlayerStateCha = _ref.onPlayerStateChanged,
      onPlayerStateChanged = _ref$onPlayerStateCha === void 0 ? noop : _ref$onPlayerStateCha;

  var _React$useState = useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      isReady = _React$useState2[0],
      setIsReady = _React$useState2[1];

  var _React$useState3 = useState(''),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      deviceId = _React$useState4[0],
      setDeviceId = _React$useState4[1];

  var playerRef = useRef(null);
  useEffect(function () {
    if (window.Spotify) {
      playerRef.current = new Spotify.Player({
        name: name,
        getOAuthToken: function () {
          var _getOAuthToken2 = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee(cb) {
            var token;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return _getOAuthToken();

                  case 2:
                    token = _context.sent;
                    cb(token);

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function getOAuthToken(_x) {
            return _getOAuthToken2.apply(this, arguments);
          }

          return getOAuthToken;
        }()
      });
      setIsReady(true);
    }

    window.onSpotifyWebPlaybackSDKReady = function () {
      playerRef.current = new Spotify.Player({
        name: name,
        getOAuthToken: function () {
          var _getOAuthToken3 = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee2(cb) {
            var token;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return _getOAuthToken();

                  case 2:
                    token = _context2.sent;
                    cb(token);

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function getOAuthToken(_x2) {
            return _getOAuthToken3.apply(this, arguments);
          }

          return getOAuthToken;
        }()
      });
      setIsReady(true);
    };

    if (!window.Spotify) {
      var scriptTag = document.createElement('script');
      scriptTag.src = 'https://sdk.scdn.co/spotify-player.js';
      document.head.appendChild(scriptTag);
    }
  }, []);
  var handleReady = useCallback(function (_ref2) {
    var readyDeviceId = _ref2.device_id;
    setDeviceId(readyDeviceId);

    if (onReady) {
      onReady(deviceId);
    }
  }, []);
  useEffect(function () {
    if (isReady) {
      playerRef.current.connect();
    }
  }, [isReady]);
  useEffect(function () {
    var player = playerRef.current;

    if (isReady) {
      player.addListener('account_error', accountError);
      player.addListener('ready', handleReady);
      player.addListener('initialization_error', accountError);
      player.addListener('authentication_error', accountError);
      player.addListener('not_ready', accountError);
      player.addListener('player_state_changed', onPlayerStateChanged);
      return function () {
        player.removeListener('account_error', accountError);
        player.removeListener('ready', handleReady);
        player.removeListener('player_state_changed', onPlayerStateChanged);
      };
    }

    return;
  }, [isReady, onPlayerStateChanged]);
  return {
    player: playerRef.current,
    deviceId: deviceId,
    isReady: isReady
  };
}

export { useSpotifyWebPlaybackSdk };
